# 🧠 AI 助手记忆系统

## 📋 概述

基于对优秀 AI Agent 项目（Mem0、LangChain Memory、Redis Memory）的研究，实现了一个三层记忆架构：

### 记忆架构

```
┌─────────────────────────────────────┐
│   短期记忆（对话上下文）              │
│   - 当前会话的对话历史                │
│   - 临时待审批操作                   │
└─────────────────────────────────────┘
           ↓ 自动提取 ↓
┌─────────────────────────────────────┐
│   情景记忆（Episodic Memory）        │
│   - 用户的行为模式和习惯              │
│   - 最近的重要互动记录                │
│   - 示例: "每周三说没时间健身"        │
└─────────────────────────────────────┘
           ↑ 主动/被动加载 ↑
┌─────────────────────────────────────┐
│   语义记忆（Semantic Memory）        │
│   - 用户偏好和喜好                   │
│   - 重要的个人信息                   │
│   - 示例: "喜欢早上运动"             │
└─────────────────────────────────────┘
```

---

## 🎯 核心功能

### 1. **主动记忆** - AI 自动识别并保存

当用户说出包含以下特征的话时，AI 会自动调用 `save_memory` 保存：

- **偏好表达**: "我喜欢..."、"我不喜欢..."、"我更喜欢..."
- **习惯描述**: "我总是..."、"我从不..."、"我习惯..."
- **重要事实**: "我的工作制是..."、"我每周要..."

**示例对话**：
```
用户: "我喜欢早上运动，晚上运动我会睡不着"
AI: [调用 save_memory('preference', '喜欢早上运动，晚上运动会影响睡眠', 0.8)]
AI: "好的，我记住了你喜欢早上运动。以后安排运动时我会优先建议早上的时段！"
```

### 2. **被动记忆** - 每次对话开始自动加载

- 对话开始时，自动从数据库加载最重要的记忆
- 注入到 System Prompt，让 AI 在整个对话中都"记得"这些信息
- 无需用户重复说明偏好

**记忆注入格式**：
```
**关于用户的记忆**：
偏好：
- 喜欢早上运动，晚上运动会影响睡眠
- 不喜欢周末安排工作任务

习惯模式：
- 每周三经常没时间完成健身计划
- 倾向于晚上11点后还在工作

重要信息：
- 工作制是大小周
- 健身目标：每周3次
```

### 3. **智能遗忘** - 自动清理低价值记忆

```dart
// 定期清理（90天未使用且重要性<0.3的记忆）
await memoryService.cleanupOldMemories(
  minImportance: 0.3,
  minUseCount: 1,
  keepDays: 90,
);
```

---

## 🗂️ 记忆类型

| 类型 | 用途 | 示例 | 重要性建议 |
|------|------|------|------------|
| **preference** | 用户偏好 | "喜欢早上运动" | 0.7-0.9 |
| **habit** | 行为习惯 | "每周三没时间健身" | 0.4-0.6 |
| **fact** | 重要事实 | "工作制是大小周" | 0.6-0.8 |
| **episode** | 情景记录 | 自动生成的对话摘要 | 0.3-0.5 |

---

## 📊 数据库结构

```sql
CREATE TABLE user_memories (
  id TEXT PRIMARY KEY,
  type TEXT NOT NULL,           -- preference/habit/fact/episode
  content TEXT NOT NULL,        -- 记忆内容
  created_at TEXT NOT NULL,     -- 创建时间
  last_used TEXT,               -- 最后使用时间
  use_count INTEGER DEFAULT 0,  -- 使用次数
  importance REAL DEFAULT 0.5,  -- 重要性(0-1)
  metadata TEXT                 -- JSON 格式的额外数据
);

CREATE INDEX idx_memories_type ON user_memories(type);
CREATE INDEX idx_memories_importance ON user_memories(importance DESC);
```

---

## 🔧 API 使用示例

### 保存记忆

```dart
final memory = MemoryEntry(
  id: '${DateTime.now().millisecondsSinceEpoch}_preference',
  type: MemoryType.preference,
  content: '喜欢早上运动',
  createdAt: DateTime.now(),
  importance: 0.8,
);

await memoryService.saveMemory(memory);
```

### 获取记忆摘要

```dart
final summary = await memoryService.getMemorySummary(
  maxPreferences: 5,  // 最多5条偏好
  maxHabits: 3,       // 最多3条习惯
  maxFacts: 5,        // 最多5条事实
  maxEpisodes: 2,     // 最近2条情景
);

// 注入到 System Prompt
final systemPrompt = basePrompt + summary.toPromptText();
```

### 搜索记忆

```dart
// 模糊搜索
final memories = await memoryService.searchMemories('运动');

// 按类型获取
final habits = await memoryService.getMemoriesByType(MemoryType.habit);
```

---

## 💡 实际应用场景

### 场景 1: 个性化建议

**无记忆时**：
```
用户: "我今天没时间健身了"
AI: "那明天找个时间补上吧"
```

**有记忆时**：
```
用户: "我今天没时间健身了"
AI: [读取记忆: "喜欢早上运动"]
AI: "我看你明天早上7-9点没有安排，而且你喜欢早上运动，要不明早7点安排个晨跑？"
```

### 场景 2: 避免重复询问

**无记忆时**：
```
第1天：AI: "你的工作制是什么？大小周还是单双休？"
第2天：AI: "你的工作制是什么？"  ← 又问一遍
```

**有记忆时**：
```
第1天：
用户: "我是大小周"
AI: [保存: fact="工作制是大小周"]

第2天：
AI: [自动加载记忆]
AI: "你这周是大周，周末还要上班，要不周五晚上早点休息？"  ← 直接知道
```

### 场景 3: 习惯模式识别

AI 会自动识别重复出现的模式：

```
Week 1: 用户周三说"没时间健身"
Week 2: 用户周三又说"没时间健身"
Week 3:
  → AI 自动保存: habit="每周三经常没时间完成健身"
  → 下次建议: "你周三通常比较忙，要不把健身安排到周二或周四？"
```

---

## 🚀 与其他优秀项目的对比

| 特性 | 本项目 | Mem0 | LangChain Memory |
|------|--------|------|------------------|
| **本地存储** | ✅ SQLite | ❌ 需云服务 | ✅ 支持 |
| **自动提取** | ✅ 简单规则 | ✅ AI提取 | ❌ 需手动 |
| **重要性评分** | ✅ | ✅ | ❌ |
| **智能遗忘** | ✅ | ✅ | ❌ |
| **零成本** | ✅ | ❌ 付费 | ✅ |
| **隐私保护** | ✅ 完全本地 | ❌ 云端 | ✅ 可本地 |

---

## 📈 未来可优化方向

### 1. **向量检索**（高级）
使用向量数据库实现语义搜索：
```dart
// 当前：精确匹配
searchMemories('运动')  // 只能找到包含"运动"的记忆

// 升级后：语义搜索
searchMemories('锻炼')  // 能找到"健身"、"运动"、"跑步"等相关记忆
```

### 2. **自动模式识别**（中级）
使用简单统计识别习惯：
```dart
// 检测重复模式
if (周三说没时间健身的次数 >= 3) {
  保存: habit="每周三通常比较繁忙，难以安排健身"
}
```

### 3. **记忆冲突检测**（简单）
```dart
// 新记忆："喜欢晚上运动"
// 已有记忆："喜欢早上运动，晚上运动会影响睡眠"
→ 提示用户：您之前说过喜欢早上运动，现在要改成晚上吗？
```

---

## 🎓 设计原则（来自研究）

基于对优秀项目的研究，我们遵循以下原则：

1. **Start Simple** - 先用简单规则，后续再考虑 AI 提取
2. **Privacy First** - 所有数据存储在本地 SQLite
3. **Graceful Degradation** - 即使记忆系统失效，对话仍可正常进行
4. **User Control** - 用户可以查看、编辑、删除任何记忆
5. **Importance Decay** - 长期不用的记忆自动降低重要性

---

## 🔐 隐私和安全

- ✅ 所有记忆数据存储在本地数据库
- ✅ 不会上传到任何云服务
- ✅ 用户完全控制自己的数据
- ✅ 可随时清空所有记忆：`memoryService.clearAllMemories()`

---

## 📝 参考资料

- [Mem0: Memory for AI Agents](https://mem0.ai/blog/memory-in-agents-what-why-and-how)
- [IBM: What Is AI Agent Memory](https://www.ibm.com/think/topics/ai-agent-memory)
- [Redis: Short-term and Long-term Memory](https://redis.io/blog/build-smarter-ai-agents-manage-short-term-and-long-term-memory-with-redis/)
- [Microsoft: Function Calling Best Practices](https://learn.microsoft.com/en-us/azure/ai-foundry/openai/how-to/function-calling)

---

**总结**：这个记忆系统让 AI 助手真正"记住"用户，提供个性化、体贴的服务，同时保证隐私和数据安全。🎉
